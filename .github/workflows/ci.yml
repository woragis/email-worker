name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'
          cache-dependency-path: go.sum
      
      - name: Install dependencies
        run: go mod download
      
      - name: Run unit tests
        id: unit_tests
        run: |
          go test ./internal/... ./pkg/... -v -coverprofile=coverage.out -covermode=atomic 2>&1 | tee test-output.log
      
      - name: Generate coverage report
        run: |
          go tool cover -html=coverage.out -o coverage.html || true
          go tool cover -func=coverage.out > coverage.txt || true
      
      - name: Parse test results
        id: parse_results
        if: always()
        run: |
          # Initialize defaults
          PASSED="0"
          FAILED="0"
          COVERAGE="0%"
          
          # Extract test summary from Go test output
          if [ -f test-output.log ]; then
            # Count individual test functions first (more accurate)
            PASSED=$(grep -c "--- PASS:" test-output.log 2>/dev/null || echo "0")
            FAILED=$(grep -c "--- FAIL:" test-output.log 2>/dev/null || echo "0")
            
            # If no individual test markers found, fall back to package-level counts
            if [ "$PASSED" = "0" ] && [ "$FAILED" = "0" ]; then
              PASSED=$(grep -c "^PASS$" test-output.log 2>/dev/null || echo "0")
              FAILED=$(grep -c "^FAIL$" test-output.log 2>/dev/null || echo "0")
            fi
            
            # Extract coverage from coverage.txt
            if [ -f coverage.txt ]; then
              # Go coverage format: "total: ... (statements) XX.X%"
              # Extract the percentage after (statements)
              COVERAGE=$(grep "total:" coverage.txt | awk '{for(i=1;i<=NF;i++) if($i ~ /^[0-9]+\.[0-9]+%$/) print $i}' | head -1 || echo "0%")
              if [ "$COVERAGE" = "0%" ] || [ -z "$COVERAGE" ]; then
                # Try alternative: get the last field that contains %
                COVERAGE=$(grep "total:" coverage.txt | awk '{print $NF}' | head -1 || echo "0%")
              fi
            fi
          fi
          
          # Ensure values are set (handle empty strings)
          PASSED=${PASSED:-0}
          FAILED=${FAILED:-0}
          COVERAGE=${COVERAGE:-0%}
          
          # Ensure values are valid (GitHub Actions requires non-empty strings)
          if [ -z "$PASSED" ] || [ "$PASSED" = "" ]; then PASSED=0; fi
          if [ -z "$FAILED" ] || [ "$FAILED" = "" ]; then FAILED=0; fi
          if [ -z "$COVERAGE" ] || [ "$COVERAGE" = "" ]; then COVERAGE="0%"; fi
          
          # Write to GitHub output with proper formatting
          {
            echo "passed<<EOF"
            echo "$PASSED"
            echo "EOF"
            echo "failed<<EOF"
            echo "$FAILED"
            echo "EOF"
            echo "coverage<<EOF"
            echo "$COVERAGE"
            echo "EOF"
          } >> $GITHUB_OUTPUT
      
      - name: Generate test report
        if: always()
        run: |
          # Set defaults if outputs are empty and clean values
          PASSED=$(echo "${{ steps.parse_results.outputs.passed }}" | xargs | grep -oE '^[0-9]+$' || echo "0")
          FAILED=$(echo "${{ steps.parse_results.outputs.failed }}" | xargs | grep -oE '^[0-9]+$' || echo "0")
          COVERAGE=$(echo "${{ steps.parse_results.outputs.coverage }}" | xargs | grep -oE '^[0-9]+\.[0-9]+%$|^[0-9]+%$' || echo "0%")
          
          # Final defaults
          PASSED=${PASSED:-0}
          FAILED=${FAILED:-0}
          COVERAGE=${COVERAGE:-0%}
          
          {
            echo "## âœ… Unit Tests Report"
            echo ""
            echo "### Test Results"
            echo ""
            echo "| Metric | Value |"
            echo "|--------|-------|"
            echo "| âœ… Passed | $PASSED |"
            echo "| âŒ Failed | $FAILED |"
            echo "| ðŸ“Š Coverage | $COVERAGE |"
            echo ""
          } >> $GITHUB_STEP_SUMMARY
          
          if [ "$FAILED" != "0" ] && [ "$FAILED" != "" ]; then
            {
              echo "### âš ï¸ Test Failures Detected"
              echo "Check the test output above for details."
              echo ""
            } >> $GITHUB_STEP_SUMMARY
          fi
          
          # Add coverage details if available
          if [ -f coverage.html ]; then
            {
              echo "### Coverage Details"
              echo "Coverage report is available in the artifacts section."
              echo ""
            } >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Upload test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-logs
          path: test-output.log
          retention-days: 7
          if-no-files-found: ignore
      
      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-coverage-reports
          path: |
            coverage.out
            coverage.html
            coverage.txt
          retention-days: 30
          if-no-files-found: ignore
      
      - name: Check coverage threshold
        if: always()
        run: |
          if [ -f coverage.txt ]; then
            # Extract coverage percentage from coverage.txt
            # Go format: "total: ... (statements) XX.X%"
            COVERAGE_PCT=$(grep "total:" coverage.txt | awk '{for(i=1;i<=NF;i++) if($i ~ /^[0-9]+\.[0-9]+%$/) print $i}' | sed 's/%//' | head -1 || echo "0")
            if [ -z "$COVERAGE_PCT" ] || [ "$COVERAGE_PCT" = "0" ]; then
              # Try alternative: get the last field and remove %
              COVERAGE_PCT=$(grep "total:" coverage.txt | awk '{print $NF}' | sed 's/%//' | head -1 || echo "0")
            fi
            COVERAGE_PCT=${COVERAGE_PCT%.*}  # Remove decimal
            COVERAGE_PCT=${COVERAGE_PCT:-0}  # Default to 0 if empty
            if [ -z "$COVERAGE_PCT" ]; then
              COVERAGE_PCT=0
            fi
            if [ "$COVERAGE_PCT" -lt 60 ]; then
              echo "âš ï¸ Coverage is below 60%: ${COVERAGE_PCT}%"
              exit 1
            else
              echo "âœ… Coverage meets threshold: ${COVERAGE_PCT}%"
            fi
          else
            echo "âš ï¸ coverage.txt not found, skipping threshold check"
          fi

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    
    services:
      rabbitmq:
        image: rabbitmq:3.13-management-alpine
        ports:
          - 5673:5672
        env:
          RABBITMQ_DEFAULT_USER: test
          RABBITMQ_DEFAULT_PASS: test
          RABBITMQ_DEFAULT_VHOST: /
        options: >-
          --health-cmd "rabbitmq-diagnostics -q ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'
          cache-dependency-path: go.sum
      
      - name: Install dependencies
        run: go mod download
      
      - name: Wait for RabbitMQ to be ready
        run: |
          echo "Waiting for RabbitMQ to be ready..."
          # Get the RabbitMQ container ID
          RABBITMQ_CONTAINER=$(docker ps -q --filter ancestor=rabbitmq:3.13-management-alpine)
          if [ -z "$RABBITMQ_CONTAINER" ]; then
            echo "RabbitMQ container not found"
            exit 1
          fi
          echo "RabbitMQ container ID: $RABBITMQ_CONTAINER"
          
          # Wait for RabbitMQ to be fully ready (can execute commands)
          echo "Waiting for RabbitMQ to accept commands..."
          for i in {1..30}; do
            if docker exec $RABBITMQ_CONTAINER rabbitmqctl status >/dev/null 2>&1; then
              echo "RabbitMQ is ready"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "RabbitMQ did not become ready in time"
              exit 1
            fi
            echo "Waiting for RabbitMQ... ($i/30)"
            sleep 2
          done
          
          # Wait a bit more for RabbitMQ to fully initialize
          sleep 5
          
          # Create /test vhost (ignore error if it already exists)
          echo "Creating /test vhost..."
          if ! docker exec $RABBITMQ_CONTAINER rabbitmqctl add_vhost /test 2>&1; then
            echo "Vhost /test may already exist, continuing..."
          fi
          
          # Grant permissions to test user on /test vhost
          echo "Granting permissions to test user on /test vhost..."
          MAX_RETRIES=5
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if docker exec $RABBITMQ_CONTAINER rabbitmqctl set_permissions -p /test test ".*" ".*" ".*" 2>&1; then
              echo "Permissions set successfully on /test vhost"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Failed to set permissions (attempt $RETRY_COUNT/$MAX_RETRIES), retrying..."
                sleep 3
              else
                echo "Failed to set permissions after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Also ensure test user has permissions on default vhost
          echo "Granting permissions to test user on default vhost..."
          docker exec $RABBITMQ_CONTAINER rabbitmqctl set_permissions -p / test ".*" ".*" ".*" 2>&1 || echo "Note: Default vhost permissions may already be set"
          
          # Verify permissions were set
          echo "Verifying permissions on /test vhost..."
          docker exec $RABBITMQ_CONTAINER rabbitmqctl list_permissions -p /test 2>&1
          echo ""
          echo "Listing all vhosts:"
          docker exec $RABBITMQ_CONTAINER rabbitmqctl list_vhosts 2>&1
          echo ""
          echo "Listing all users:"
          docker exec $RABBITMQ_CONTAINER rabbitmqctl list_users 2>&1
          echo ""
          echo "RabbitMQ is ready with vhosts configured"
      
      - name: Run integration tests
        id: integration_tests
        env:
          # Use the RabbitMQ service container (using /test vhost)
          RABBITMQ_URL: amqp://test:test@localhost:5673/test
          SMTP_HOST: ${{ secrets.SMTP_HOST || 'localhost' }}
          SMTP_FROM: ${{ secrets.SMTP_FROM || 'test@example.com' }}
        run: |
          go test ./internal/integration/... -v -tags=integration 2>&1 | tee test-output.log || true
        continue-on-error: true
      
      - name: Parse integration test results
        id: parse_integration_results
        if: always()
        run: |
          # Initialize defaults
          PASSED="0"
          FAILED="0"
          SKIPPED="0"
          
          # Extract test summary from Go test output
          if [ -f test-output.log ]; then
            # Count individual test functions first (more accurate)
            PASSED=$(grep -c "--- PASS:" test-output.log 2>/dev/null || echo "0")
            FAILED=$(grep -c "--- FAIL:" test-output.log 2>/dev/null || echo "0")
            
            # If no individual test markers found, fall back to package-level counts
            if [ "$PASSED" = "0" ] && [ "$FAILED" = "0" ]; then
              PASSED=$(grep -c "^PASS$" test-output.log 2>/dev/null || echo "0")
              FAILED=$(grep -c "^FAIL$" test-output.log 2>/dev/null || echo "0")
            fi
            
            # Count skipped tests (if any)
            SKIPPED=$(grep -c "SKIP:" test-output.log 2>/dev/null || echo "0")
          fi
          
          # Ensure values are set (handle empty strings)
          PASSED=${PASSED:-0}
          FAILED=${FAILED:-0}
          SKIPPED=${SKIPPED:-0}
          
          # Ensure values are valid (GitHub Actions requires non-empty strings)
          if [ -z "$PASSED" ] || [ "$PASSED" = "" ]; then PASSED=0; fi
          if [ -z "$FAILED" ] || [ "$FAILED" = "" ]; then FAILED=0; fi
          if [ -z "$SKIPPED" ] || [ "$SKIPPED" = "" ]; then SKIPPED=0; fi
          
          # Write to GitHub output with proper formatting
          {
            echo "passed<<EOF"
            echo "$PASSED"
            echo "EOF"
            echo "failed<<EOF"
            echo "$FAILED"
            echo "EOF"
            echo "skipped<<EOF"
            echo "$SKIPPED"
            echo "EOF"
          } >> $GITHUB_OUTPUT
      
      - name: Generate integration test report
        if: always()
        run: |
          # Set defaults if outputs are empty and clean values
          PASSED=$(echo "${{ steps.parse_integration_results.outputs.passed }}" | xargs | grep -oE '^[0-9]+$' || echo "0")
          FAILED=$(echo "${{ steps.parse_integration_results.outputs.failed }}" | xargs | grep -oE '^[0-9]+$' || echo "0")
          SKIPPED=$(echo "${{ steps.parse_integration_results.outputs.skipped }}" | xargs | grep -oE '^[0-9]+$' || echo "0")
          
          # Final defaults
          PASSED=${PASSED:-0}
          FAILED=${FAILED:-0}
          SKIPPED=${SKIPPED:-0}
          
          {
            echo "## ðŸ”— Integration Tests Report"
            echo ""
            echo "### Test Results"
            echo ""
            echo "| Metric | Value |"
            echo "|--------|-------|"
            echo "| âœ… Passed | $PASSED |"
            echo "| âŒ Failed | $FAILED |"
            echo "| â­ï¸ Skipped | $SKIPPED |"
            echo ""
          } >> $GITHUB_STEP_SUMMARY
          
          if [ "$FAILED" != "0" ]; then
            echo "### âš ï¸ Integration Test Failures" >> $GITHUB_STEP_SUMMARY
            echo "Some integration tests failed. This may be expected if external services are not configured." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "$SKIPPED" != "0" ]; then
            echo "### â„¹ï¸ Skipped Tests" >> $GITHUB_STEP_SUMMARY
            echo "Some tests were skipped, likely due to missing external service dependencies." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Upload integration test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-logs
          path: test-output.log
          retention-days: 7
          if-no-files-found: ignore

  docker-build:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [unit-tests]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker image
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: email-worker:test
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Test Docker image
        run: |
          docker run --rm email-worker:test --help || docker run --rm email-worker:test /bin/sh -c "echo 'Image works!'" || true
      
      - name: Generate Docker build report
        if: always()
        run: |
          echo "## ðŸ³ Docker Build Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… **Docker image built successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Image tag: \`email-worker:test\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The image has been validated and is ready for deployment." >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Docker build failed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the build logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests, docker-build]
    if: always()
    
    steps:
      - name: Generate overall summary
        run: |
          echo "## ðŸ“Š CI Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Job Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | ${{ needs.unit-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | ${{ needs.integration-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Build | ${{ needs.docker-build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Determine overall status
          if [ "${{ needs.unit-tests.result }}" == "success" ] && \
             [ "${{ needs.docker-build.result }}" == "success" ]; then
            echo "### âœ… Overall Status: Success" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All critical checks passed. The service is ready for deployment." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Overall Status: Failure" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Some checks failed. Please review the job logs above." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Artifacts Available" >> $GITHUB_STEP_SUMMARY
          echo "- Unit test logs and coverage reports" >> $GITHUB_STEP_SUMMARY
          echo "- Integration test logs" >> $GITHUB_STEP_SUMMARY
          echo "- Coverage HTML reports (in artifacts)" >> $GITHUB_STEP_SUMMARY

